class RpcTable {
    
   
    /** @type {HTMLTableElement} */
    table;

    /** @type {Array<HTMLTableRowElement>} */
    #children;

    /** @type {Object<string, number>} */
    #breakpoints;

    /**
     * @returns {Array<string>}
     */
    get tableHeaders() {
        return [...this.table.querySelectorAll("tr:nth-child(1) th")]
            .map((node) => node.innerHTML);
    }

    /**
     * 
     * @param {string} selector CSS selector
     * @param {Object} options 
     */
    constructor(selector, options = {}) {
        this.table = document.querySelector(selector);
        this.table.classList.add("rpc");

        this.#children = [];
        this.#breakpoints = {
            "collapse-xs": 576,
            "collapse-sm": 768,
            "collapse-md": 992,
            "collapse-lg": 1200,
            "collapse": Number.MAX_SAFE_INTEGER,
        }

        this.process();
        this.table.addEventListener("click", this.#togglerHandle.bind(this))
        window.addEventListener("resize", this.#handleResize.bind(this))
    }

    /**
     * @returns {Array<string>}
     */
    hiddenClasses() {
        return Object.keys(this.#breakpoints)
            .filter((k) => this.#breakpoints[k] >= window.innerWidth)
    }

    /**
     * @param {Event} event 
     */
    render(event) {
        this.table.querySelectorAll("thead th").forEach((th, i) => {
            let responsive = [...th.classList].filter(c => Object.keys(this.#breakpoints).includes)[0]

            this.table.querySelectorAll(`tbody tr:not(.child) td:nth-child(${i + 1})`).forEach((td) => {
                if (responsive)
                    td.classList.add(responsive)

                if (responsive && this.hiddenClasses().includes(responsive)) {
                    th.classList.add("rpc-hidden")
                    td.classList.add("rpc-hidden")
                } else {
                    th.classList.remove("rpc-hidden")
                    td.classList.remove("rpc-hidden")
                }
            });
        });

        this.table.querySelectorAll("tbody tr:not(.child)").forEach((tr, i) => {           
            for (let td of tr.cells) {
                if ([...td.classList].includes("rpc-hidden")) {
                    if (this.#inChild(this.#children[i], tr.rowIndex, td.cellIndex))
                        continue
                    this.#removeChildRow(this.#children[i], tr.rowIndex, td.cellIndex)
                } else {
                    if (!this.#inChild(this.#children[i], tr.rowIndex, td.cellIndex))
                        continue
                    this.#createChildRow(this.#children[i], tr.rowIndex, td.cellIndex)
                }
            }
        })
    }

    process() {
        this.#children = [];

        this.table.querySelectorAll("thead th").forEach((th, i) => {
            let responsive = [...th.classList].filter(c => Object.keys(this.#breakpoints).includes)[0]

            this.table.querySelectorAll(`tbody tr:not(.child) td:nth-child(${i + 1})`).forEach((td) => {
                if (responsive)
                    td.classList.add(responsive)

                if (responsive && this.hiddenClasses().includes(responsive)) {
                    th.classList.add("rpc-hidden")
                    td.classList.add("rpc-hidden")
                } else {
                    th.classList.remove("rpc-hidden")
                    td.classList.remove("rpc-hidden")
                }
            });
        });

        this.table.querySelectorAll("tbody tr:not(.child)").forEach((tr, i) => {
            let child = this.#createChild(tr)

            if (child) {
                this.#children.push(child)
                tr.classList.add("has-child")
            }

            this.#makeToggler(tr)
        })

        this.render();
    }

    /**
     * @param {HTMLTableRowElement} tr 
     */
    #makeToggler(tr) {
        tr.querySelector('td.rpc-toggler')?.classList.remove("rpc-toggler");
        if ([...tr.classList].includes("has-child")) {
            tr.querySelector('td:not(.rpc-hidden)').classList.add("rpc-toggler");
        }
    }

    /**
     * @param {HTMLTableRowElement} tr 
     * @returns {HTMLElement}
     */
    #createChild(tr) {
        let newTr = Object.assign(document.createElement("tr"), {
            classList: ["child"],
            colspan: "100%",
            innerHTML: "<td colspan=\"100%\"><ul></ul></td>",
        });

        tr.querySelectorAll("td").forEach((td, i) => {
            if (![...td.classList].includes("rpc-hidden")) {
                return;
            }
            newTr.querySelector("td ul").appendChild(this.#createChildRow(td))
        });
        return newTr.querySelector("td ul").children.length > 0 ? newTr : null;
    }

    /**
     * @param {HTMLTableRowElement} tr
     * @returns {HTMLElement}
     */
    #modifyChild(tr) {
        const child = this.#children[tr.rowIndex - 1];

        const hiddenColIdx = [...this.table.querySelectorAll("thead > tr:first-child > th.rpc-hidden")]
            .map((th) => th.cellIndex.toString())

        child.querySelectorAll("ul > li").forEach((li, i) => {
            if (hiddenColIdx.includes(li.dataset.column)) {
                // child.querySelector("ul").appendChild(this.#createChildRow(this.table.rows[li.dataset.row].cells[li.dataset.column]))   
            } else {
                this.#removeChildRow(li)
            }

        })
    }

    /**
     * 
     * @param {HTMLTableRowElement} child
     * @param {number} row 
     * @param {number} column
     * @returns {boolean}
     */
    #inChild(child, row, column) {
        for (let li of child.querySelectorAll("ul > li")) {
            if (li.dataset.row == row && li.dataset.column == column) {
                return true
            }
        }
        return false
    }

    /**
     * 
     * @param {HTMLTableRowElement} child
     * @param {number} row 
     * @param {number} column
     */
    #removeChildRow(child, row, column) {
        let span = child.querySelector("tr > ul > li > span.rpc-child-value")
        if (span.children.length > 0) {
            this.table.rows[li.dataset.row].cells[li.dataset.column].append(...span.children)
        } else {
            this.table.rows[li.dataset.row].cells[li.dataset.column].innerHTML = span.innerHTML
        }
        li.remove()
    }

    /**
     * 
     * @param {HTMLTableRowElement} child
     * @param {number} row 
     * @param {number} column
     */
    #createChildRow(child, row, column) {
        let li = document.createElement("li");

        li.dataset.row = row;
        li.dataset.column = column;

        li.appendChild(Object.assign(document.createElement("span"), {
            classList: ["rpc-child-title"],
            innerHTML: this.tableHeaders[column],
        }))

        li.appendChild(Object.assign(document.createElement("span"), {
            classList: ["rpc-child-value"],
        }))

        if (td.children.length > 0) {
            li.children[1].append(...td.children)
        } else {
            li.children[1].innerHTML = td.innerText
        }

        
        let ul = child.querySelector("tr > ul")
        if (ul.children.length == 0) {
            ul.appendChild(li)
        } else {
            for (let ulli of ul) {
                if (ulli.dataset.column >= column)
                    continue
                ulli.after(li)
            }
        }
    }

    /**
     * @param {PointerEvent} event
     */
    #togglerHandle(event) {
        if (![...event.target.classList].includes("rpc-toggler"))
            return

        let tr = event.target.closest("tr");
        if (tr.classList.contains("rpc-expanded")) {
            tr.nextSibling.remove()
        } else {
            tr.after(this.#children[tr.rowIndex - 1])
        }

        tr.classList.toggle("rpc-expanded")
    }
}